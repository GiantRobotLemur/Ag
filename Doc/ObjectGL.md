# Object GL

A C++ wrapper for the OpenGL API Specification.

## Motivation

OpenGL is a challenging graphics API specification with decades of baggage.
Although it is not being actively updated, it is mature and supported across
multiple platforms. Vulkan can be used to perform higher performance rendering, 
but requires the programmer to do a lot more of the heavy lifting. Both have their
foibles.

That said, OpenGL, like Vulkan, is an *API specification* created by the
[Khronos Group](https://www.khronos.org), not a library. To get it working on
any platform, you need to do a bit of platform-specific heavy lifting and then
resolve the entry points for all the functions you want to use.

Libraries exist for some of this like glFW, which will give you a set of
cryptic C headers and then leave you to figure the rest out. However, the Khronos
header files are not the root of truth for the OpenGL API. The Khronos OpenGL
Registry points to a [github repository](https://github.com/KhronosGroup/OpenGL-Registry)
that contains an XML file from which the header files are derived (via a
Python script).

While C is a useful way to express the OpenGL API, it isn't the only way and
the XML API specification contains additional useful metadata which cannot be
expressed as a C API. To that end, I wrote a C# tool which parses the XML and
uses it to generate a more useful set of C++ data structures which can resolve
the entries points into the underlying OpenGL implementation, but also wraps
them to add error detection, exceptions and namespacing of constants and
resource identifiers.

In the C interpretation of OpenGL, the only way to tell if a command failed
is by calling another function. Also, there is no way to tell the difference
between the identifier (the 'name' in OpenGL parlance) of a texture and that
of a shader program. These namespaces are described in the API specification
and the wrappers I have created only allow a appropriate resources to be
used with commands that expect them.

The API specification also describes which sets of constants should be grouped
for common purpose. In the Object GL library, these values are turned into
enum classes which make the implied grouping much more explicit.

## Contents

So, based on the C++ generated by my bespoke tool (which I must put on github
at some point), we get a number of API structures. Each contains a set of
function pointers and the means to resolve them if a suitable resolver
implementation is provided. For example, the main set of core profile OpenGL
commands can be found in `gl::GL` in `APIs.hpp`. It has a `resolveEntryPoints()`
member function which will try to fill in the fields with pointers to
functions in the current context.

Microsoft Windows-specific and X-Window System-specific entry points are defined
in similar structures, `wgl::WGL` and `glx::GLX`, respectively. In addition,
each extension described in the OpenGL registry has it's own structured collection
of function pointers, for example `gl::ARBDebugOutput`. If an extension is found
to be present, the data structure can be instantiated and its entry points
resolved at runtime. A reference to the structure can then be passed around to
the components that need it as required.

On top of these entry point structures is layered a high level API interface. For
core OpenGL, WGL and GLX, these are `gl::GLAPI`, `wgl::WGLAPI` and `glx::GLXAPI`
respectively. Each contains a set of member functions which check the entry
point is available, marshal parameters to the types required by the raw entry point,
checks for errors once the command is complete and marshals return types back to
the higher level types required.

For example `gl::ShaderName gl::GLAPI::createShader(ShaderType type)`. This wraps
the `GLuint glCreateShader(GLenum type)` entry point. The high level version
translates the `ShaderType` enumeration value to an generic `GLenum` input. The
resultant `GLuint` is wrapped in a `gl::ShaderName` structure which can only
be used with high level functions that require a `GLuint` that defines an OpenGL
shader resource.

## Platform Support

Being able to get a program to a point where it can start resolving API entry
points can be quite a tricky task. Under raw Win32, you have to create a legacy
OpenGL context so that you can discover how to make a modern OpenGL context and
then you have to do that with a different window. libSDL makes the process a lot
easier, but still leaves you to resolve your entry points (via
`SDL_GL_GetProcAddress()`).

Object GL contains a number of drivers which eases the process of creating,
managing and switching OpenGL contexts. Each platform uses different data types
and has different requirements for performing these tasks. ObjectGL hides this
mechanism behind a driver interface which allows you to create a
`DisplayContext` object which can be used to query for system capabilities. It
can then be used to create a `RenderContext` which wraps the platform-specific
OpenGL context and helps manage and dispose of graphic resources, such as shader
programs and buffers.

## Resources Wrappers

Work is afoot to create C++ object wrappers for commonly used OpenGL resources
such as buffers, vertex array objects, shaders and programs. This work is
incomplete, but is built on top of the API and context management infrastructure
described above. It will be fleshed out and grow as I begin working on OpenGL
projects in the future.